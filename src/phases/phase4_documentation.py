"""
HyperMatrix v2026 - Phase 4: Documentation Generation
Auto-generates documentation from analyzed code.
"""

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Optional
from datetime import datetime

from ..core.db_manager import DBManager


@dataclass
class DocSection:
    """A section in the documentation."""
    title: str
    content: str
    level: int = 1
    subsections: list = None

    def __post_init__(self):
        if self.subsections is None:
            self.subsections = []


class DocumentationGenerator:
    """Generate documentation from analyzed code."""

    def __init__(self, db_manager: DBManager):
        self.db = db_manager

    def generate_project_docs(
        self,
        project_id: int,
        output_dir: str,
        format: str = "markdown",
    ) -> list[str]:
        """Generate full documentation for a project."""
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        generated_files = []

        # Get project info
        project = self.db.get_project(project_id)
        if not project:
            raise ValueError(f"Project {project_id} not found")

        # Generate main README
        readme_path = output_path / "README.md"
        self._generate_readme(project_id, project, readme_path)
        generated_files.append(str(readme_path))

        # Generate API documentation
        api_path = output_path / "API.md"
        self._generate_api_docs(project_id, api_path)
        generated_files.append(str(api_path))

        # Generate module documentation
        modules_dir = output_path / "modules"
        modules_dir.mkdir(exist_ok=True)
        module_files = self._generate_module_docs(project_id, modules_dir)
        generated_files.extend(module_files)

        # Generate class diagram (Mermaid)
        diagram_path = output_path / "CLASS_DIAGRAM.md"
        self._generate_class_diagram(project_id, diagram_path)
        generated_files.append(str(diagram_path))

        # Generate index
        index_path = output_path / "INDEX.md"
        self._generate_index(project_id, generated_files, index_path)
        generated_files.append(str(index_path))

        return generated_files

    def _generate_readme(self, project_id: int, project: dict, output_path: Path):
        """Generate main README file."""
        stats = self.db.get_statistics(project_id)

        content = f"""# {project["name"]}

> Auto-generated documentation by HyperMatrix v2026

## Overview

| Metric | Value |
|--------|-------|
| Total Files | {stats.get("total_files", 0)} |
| Functions | {stats.get("total_functions", 0)} |
| Classes | {stats.get("total_classes", 0)} |
| Imports | {stats.get("total_imports", 0)} |

**Root Path:** `{project["root_path"]}`

**Analyzed:** {datetime.now().strftime("%Y-%m-%d %H:%M")}

## Project Structure

"""
        # Get file tree
        with self.db._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT filepath, file_type FROM files
                WHERE project_id = ? ORDER BY filepath
            """, (project_id,))

            files = cursor.fetchall()

            # Build simple tree
            root_path = Path(project["root_path"])
            for f in files[:50]:  # Limit to 50 files
                try:
                    rel_path = Path(f["filepath"]).relative_to(root_path)
                    indent = "  " * (len(rel_path.parts) - 1)
                    content += f"{indent}- `{rel_path.name}` ({f['file_type']})\n"
                except ValueError:
                    content += f"- `{Path(f['filepath']).name}` ({f['file_type']})\n"

            if len(files) > 50:
                content += f"\n*... and {len(files) - 50} more files*\n"

        content += """
## Documentation Index

- [API Documentation](API.md)
- [Class Diagram](CLASS_DIAGRAM.md)
- [Module Documentation](modules/)

---
*Generated by HyperMatrix v2026*
"""

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)

    def _generate_api_docs(self, project_id: int, output_path: Path):
        """Generate API documentation for all functions."""
        content = """# API Documentation

> All functions extracted from the codebase

"""
        with self.db._get_connection() as conn:
            cursor = conn.cursor()

            # Get all functions with their details
            cursor.execute("""
                SELECT f.name, f.lineno, f.parameters, f.return_type,
                       f.docstring, f.is_async, fi.filepath
                FROM functions f
                JOIN files fi ON f.file_id = fi.id
                WHERE fi.project_id = ?
                ORDER BY fi.filepath, f.name
            """, (project_id,))

            functions = cursor.fetchall()

            current_file = None
            for func in functions:
                filepath = func["filepath"]

                # New file section
                if filepath != current_file:
                    current_file = filepath
                    content += f"\n## {Path(filepath).name}\n\n"

                # Function signature
                params = func["parameters"] or ""
                if params:
                    try:
                        params_list = json.loads(params)
                        params = ", ".join(params_list)
                    except:
                        pass

                async_prefix = "async " if func["is_async"] else ""
                return_type = f" -> {func['return_type']}" if func["return_type"] else ""

                content += f"### `{async_prefix}{func['name']}({params}){return_type}`\n\n"
                content += f"**Line:** {func['lineno']}\n\n"

                if func["docstring"]:
                    content += f"{func['docstring']}\n\n"

                content += "---\n\n"

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)

    def _generate_module_docs(self, project_id: int, output_dir: Path) -> list[str]:
        """Generate documentation for each module/file."""
        generated = []

        with self.db._get_connection() as conn:
            cursor = conn.cursor()

            # Get all files
            cursor.execute("""
                SELECT id, filepath, file_type FROM files
                WHERE project_id = ? AND file_type = 'python'
            """, (project_id,))

            files = cursor.fetchall()

            for file_info in files:
                file_id = file_info["id"]
                filepath = file_info["filepath"]
                filename = Path(filepath).stem

                content = f"# Module: {filename}\n\n"
                content += f"**Path:** `{filepath}`\n\n"

                # Get classes
                cursor.execute("""
                    SELECT name, lineno, bases, methods, docstring
                    FROM classes WHERE file_id = ?
                """, (file_id,))
                classes = cursor.fetchall()

                if classes:
                    content += "## Classes\n\n"
                    for cls in classes:
                        bases = ""
                        if cls["bases"]:
                            try:
                                bases_list = json.loads(cls["bases"])
                                bases = f"({', '.join(bases_list)})" if bases_list else ""
                            except:
                                pass

                        content += f"### `class {cls['name']}{bases}`\n\n"
                        content += f"**Line:** {cls['lineno']}\n\n"

                        if cls["docstring"]:
                            content += f"{cls['docstring']}\n\n"

                        if cls["methods"]:
                            try:
                                methods = json.loads(cls["methods"])
                                if methods:
                                    content += "**Methods:**\n"
                                    for m in methods:
                                        content += f"- `{m}`\n"
                                    content += "\n"
                            except:
                                pass

                # Get functions
                cursor.execute("""
                    SELECT name, lineno, parameters, return_type, docstring, is_async
                    FROM functions WHERE file_id = ?
                """, (file_id,))
                functions = cursor.fetchall()

                if functions:
                    content += "## Functions\n\n"
                    for func in functions:
                        params = ""
                        if func["parameters"]:
                            try:
                                params_list = json.loads(func["parameters"])
                                params = ", ".join(params_list)
                            except:
                                params = func["parameters"]

                        async_prefix = "async " if func["is_async"] else ""
                        ret = f" -> {func['return_type']}" if func["return_type"] else ""

                        content += f"### `{async_prefix}def {func['name']}({params}){ret}`\n\n"
                        content += f"**Line:** {func['lineno']}\n\n"

                        if func["docstring"]:
                            content += f"{func['docstring']}\n\n"

                # Get imports
                cursor.execute("""
                    SELECT module, names, is_from FROM imports WHERE file_id = ?
                """, (file_id,))
                imports = cursor.fetchall()

                if imports:
                    content += "## Imports\n\n"
                    content += "```python\n"
                    for imp in imports:
                        if imp["is_from"]:
                            names = imp["names"] or "*"
                            content += f"from {imp['module']} import {names}\n"
                        else:
                            content += f"import {imp['module']}\n"
                    content += "```\n\n"

                # Write module file
                safe_name = filename.replace(".", "_").replace("/", "_").replace("\\", "_")
                module_path = output_dir / f"{safe_name}.md"
                with open(module_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                generated.append(str(module_path))

        return generated

    def _generate_class_diagram(self, project_id: int, output_path: Path):
        """Generate Mermaid class diagram."""
        content = """# Class Diagram

```mermaid
classDiagram
"""
        with self.db._get_connection() as conn:
            cursor = conn.cursor()

            # Get all classes
            cursor.execute("""
                SELECT c.name, c.bases, c.methods
                FROM classes c
                JOIN files fi ON c.file_id = fi.id
                WHERE fi.project_id = ?
            """, (project_id,))

            classes = cursor.fetchall()
            class_names = set()

            for cls in classes:
                class_name = cls["name"]
                class_names.add(class_name)

                # Add class definition
                content += f"    class {class_name} {{\n"

                # Add methods
                if cls["methods"]:
                    try:
                        methods = json.loads(cls["methods"])
                        for m in methods[:10]:  # Limit methods
                            content += f"        +{m}()\n"
                    except:
                        pass

                content += "    }\n"

                # Add inheritance
                if cls["bases"]:
                    try:
                        bases = json.loads(cls["bases"])
                        for base in bases:
                            if base not in ["object", "ABC"]:
                                content += f"    {base} <|-- {class_name}\n"
                    except:
                        pass

        content += "```\n"

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)

    def _generate_index(
        self,
        project_id: int,
        generated_files: list[str],
        output_path: Path,
    ):
        """Generate index of all documentation."""
        content = """# Documentation Index

## Generated Files

"""
        for filepath in generated_files:
            name = Path(filepath).name
            rel_path = Path(filepath).name
            content += f"- [{name}]({rel_path})\n"

        content += f"""
## Statistics

"""
        stats = self.db.get_statistics(project_id)
        content += f"- **Files Analyzed:** {stats.get('total_files', 0)}\n"
        content += f"- **Functions Documented:** {stats.get('total_functions', 0)}\n"
        content += f"- **Classes Documented:** {stats.get('total_classes', 0)}\n"

        content += """
---
*Generated by HyperMatrix v2026*
"""

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)


def run_phase4(db_manager: DBManager, project_id: int, output_dir: str) -> list[str]:
    """Run Phase 4: Documentation Generation."""
    generator = DocumentationGenerator(db_manager)
    return generator.generate_project_docs(project_id, output_dir)
